<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Page 2 | Programming is Fun | Still waters run deep. When the well&#39;s dry, we know the worth of water.</title>

  
  <meta name="author" content="ykyoon">
  

  

  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  

  <meta property="og:site_name" content="Programming is Fun"/>

  
  <meta property="og:image" content="/favicon.ico"/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="Programming is Fun" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
</head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">Programming is Fun</a>
    </h1>
    <p class="site-description">Still waters run deep. When the well&#39;s dry, we know the worth of water.</p>
  </div>
  <nav class="site-navigation">
    <ul>
      
        <li><a href="/">Home</a></li>
      
        <li><a href="/archives">Archives</a></li>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    
  <article>

  
    
    <h3 class="article-title"><a href="/2018/02/01/02-developEnd/"><span>02.팀 단위의 개발 환경</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/02/01/02-developEnd/" rel="bookmark">
        <time class="entry-date published" datetime="2018-02-01T03:42:56.000Z">
          2018-02-01
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h1 id="팀-단위의-개발-환경"><a href="#팀-단위의-개발-환경" class="headerlink" title="팀 단위의 개발 환경"></a>팀 단위의 개발 환경</h1><p>개발을 할때는 환경이 매우 중요합니다. 개발 환경을 팀의 관점으로 볼때는 단순히 업무 흐름만을 보는것은 너무 옛날 이야기가 되었습니다.<br>이제 팀 단위의 개발환경에서 거의 필수가 된 항목들은 다음과 같습니다.</p>
<ul>
<li>코드 관리 시스템</li>
<li>이슈 관리 시스템</li>
<li>자동 빌드 시스템</li>
<li>Code Review 시스템</li>
<li>자동 배포 시스템</li>
<li>로컬 개발 서버(DB 포함) - 개발자 PC</li>
<li>테스트 서버 (DB 포함)</li>
<li>배포 서버 (DB 포함)</li>
</ul>
<p>각 시스템이 유동적으로 연결되어 하나의 프로젝트가 완성이 되는 것이 일반적입니다.<br>먼저, 간단한 예를 들어보기로 하겠습니다. 여기 신입 개발자 A군과 고참 개발자 B양이 있습니다.</p>
<blockquote>
<p>B양은 이슈 관리 시스템을 통해서 자신의 팀에 주어진 일들을 확인합니다. 그리고 간단한 팀 미팅을 통해 서로간에 지금 어제 어떤 일을 했고, 오늘 어떤 일을 할 것이며, 오늘 이슈 사항이 무엇이 있는지를 파악합니다. 파악한 후, 추가로 들어온 일이 있는 경우에 그 사항을 이슈 관리시스템이 등록 또는 수정을 하고 담당자를 A군으로 지정합니다.</p>
<p>A군은 이슈 관리 시스템을 통해서 자신에게 주어진 일을 확인합니다. 그리고, 이미 분석된 업무이고, 바로 개발을 들어가게 됩니다. 먼저 코드 관리 시스템에서 소스를 최신의 것으로 Update 받습니다. 받은 Source의 History를 파악하고, DB schema의 변경사항이 있는 경우, 자신의 개발 환경에 반영을 하고 코딩을 시작합니다.</p>
<p>A군은 코딩을 열심히 해서 일을 마쳤습니다. 그리고, 소스를 코드관리 시스템에 commit을 진행합니다. 소스관리 시스템은 commit된 코드가 있음을 관리자에게 알립니다.</p>
<p>B양은 A군의 코딩 내용을 보고 Code Review를 진행합니다. 맘에 안들면 불러다가, 또는 email로 깨고, reject 시킵니다. 그렇게 되면 이 코드는 반영되지 않게 됩니다.</p>
<p>A군은 다시 코딩을 합니다. 지적 받은 사항에 대해서 다시 고치고, 다시 commit을 합니다.</p>
<p>B양은 A군의 코드를 review하면서 흐뭇해하면서 코드를 accept합니다. accept된 코드는 이제 자동 빌드 시스템으로 넘어갑니다.</p>
<p>A군은 자신이 한 일에 대해서 이슈 관리 시스템에 일의 진행정도를 알리고, 완료를 시킵니다. 물론 약간의 문서 작업도 진행합니다.</p>
<p>자동빌드 시스템은 열심히 코드를 build하고, 자동화된 test code를 모두 실행하고 그 결과를 팀원 전체에게 email로 알립니다.</p>
<p>test code가 모두 완료되면 build한 결과를 테스트 서버에 배포하게 됩니다. 이제 테스트 서버를 통해서 QC 팀들이 개발팀의 결과를 검증하게 됩니다.</p>
<p>QA 팀이 검증을 모두 마쳤습니다. 자동 배포 시스템을 통해서 실제 동작하는 서비스로 배포하게 됩니다. (모두들 수고하셨습니다.)</p>
</blockquote>
<p>이러한 과정을 거치게 되는 것이 일반적인 개발회사에서의 흐름입니다. 그리고 계속되는 통합 과정을 통해, 코드의 품질을 계속해서 높이는 과정을 하게 됩니다. 그러나… 불행히도 저희 회사는 저기 위에 있는 시스템중 반도 존재하지 않습니다.</p>
<p>실질적인 예가 아닌, 이제 좀더 본격적인 설명에 들어가보도록 하겠습니다.</p>
<h2 id="코드-관리-시스템-Repository"><a href="#코드-관리-시스템-Repository" class="headerlink" title="코드 관리 시스템 (Repository)"></a>코드 관리 시스템 (Repository)</h2><p>주로 사용되는 것은 svn과 요즘 인기를 끌고 있는 git가 있습니다. 기능으로는 code의 중앙 저장소 및 source 변경에 대한 history 관리 기능과 sync, merge 등이 있습니다.<br>저희가 자주 사용하고 있지만, 조금은 다르게 사용하고 있는것 같긴 합니다. 주 기능은 code의 저장입니다. 그렇지만, 그 이상으로 중요하다고 생각되는 기능은 code의 history입니다. 어느날 갑자기 code를 받아보니 변경사항이 있었고, 그 내용이 왜, 그리고 무엇이 변경된것인지 모른다면 예전에 code를 usb같은것으로 카피해서 주는것과 차이가 없습니다. 코드를 변경했으면, 그 code를 왜 변경했는지에 대한 log를 적어주는 것이 이 시스템을 보다 더 잘 쓰는 방법입니다.</p>
<h2 id="이슈-관리-시스템"><a href="#이슈-관리-시스템" class="headerlink" title="이슈 관리 시스템"></a>이슈 관리 시스템</h2><p>많은 이슈 관리 시스템이 존재합니다. 대표적인것으로 무료로 배포되는 것들은 trac, jtrac, redmine, bugzillar 등이 있으며 상용은 jira가 있습니다. 상용으로 판매되는 jira는 정말 좋습니다. 개인적으론 구매를 해서 사용해보고 싶은 욕심이 무척 많이 듭니다. ㅠㅠ<br>코드 관리시스템이 코드에 대한 중앙 집중형 관리라면, 이슈 관리 시스템은 왜 그 코드를 작성하게 되었는지. 우리가 프로젝트를 완료하기 위해서는 앞으로 어떤 일들을 해야지 되는지. 그리고 지금까지 우리가 어떤 일을 해왔는지에 대한 “일, 작업, Issue, Task”에 대한 기록을 남기는 장소입니다. 이슈 관리 시스템은 코드 관리 시스템과 연동되어 코드의 변경사항이 어떤 이슈와 관련이 있는지까지 같이 보여줄 수 있습니다. 또한, 대부분의 코드 관리 시스템은 wiki라는 문서 작업 공간을 같이 제공합니다. wiki를 통해 서로간에 공유할 수 있는 내용을 기록하는 것이 가능합니다.</p>
<p><img src="images/02/wiki.jpg" alt=""></p>
<h2 id="자동-빌드-시스템-자동-배포-시스템"><a href="#자동-빌드-시스템-자동-배포-시스템" class="headerlink" title="자동 빌드 시스템, 자동 배포 시스템"></a>자동 빌드 시스템, 자동 배포 시스템</h2><p>이 두개의 시스템은 거의 하나로 만들어져서 사용됩니다. 이를 CI 시스템이라고 하며, hudson, jenkins와 jetBrains 사의 TeamCity가 유명합니다. CI가 CI 가 하는 일은 소스 관리 시스템과 연결되어 commit된 소스가 있는 경우, 자신이 다운받아 build 후, test code를 실행하고 그 결과를 report로 남기는 일을 반복합니다.또한 build 결과 또는 수동으로 실서버 또는 개발서버에 배포를 할 수 있기때문에 신속하고 중지 되지 않는 통합을 가능하게 하고 있습니다.</p>
<p><img src="images/02/jenkins.png" alt=""><br><img src="images/02/jenkins2.png" alt=""></p>
<p>CI에 대하여 조금 더 알아보도록 하겠습니다.</p>
<p>다음은 CI의 기본 동작 Process를 나타내고 있습니다.</p>
<ul>
<li>Commit source code : 개발자가 자신의 code 를 commit 한다</li>
<li>Unit Test : CI가 코드에 포함된 Unit Test code를 실행한다.</li>
<li>CPM ( Continiuous Performance Management) : Unit Test 결과를 기록하고, Unit test의 실행 시간등을 기록한다.</li>
<li>License check : 만약 코드 안에 상용 library등이 포함되어 있다면, license에 대한 check를 진행한다.</li>
<li>Build : Build 및 추가 파일 복사 작업 진행</li>
<li>Deploy : Test 환경으로의 배포 ( &gt; QI 영역)</li>
</ul>
<p><img src="/images/02/ci.png" alt=""></p>
<h2 id="Code-Review-System"><a href="#Code-Review-System" class="headerlink" title="Code Review System"></a>Code Review System</h2><p>약간은 옵션적인 시스템이지만, 많은 기업들이 채용하고 있는중인 Code Review System입니다. Code Review란 간단히 사용자의 자신의 Code를 코드 관리 시스템에 Commit을 할때, 중간 단계를 하나 거치게 하는 것입니다. 그 중간단계에서 상임 개발자들이 그 코드를 평가하고, 원활히 변경된 경우에 그 코드를 코드 관리 시스템에 반영하는 절차를 추가한 시스템입니다. CodeCollaboration 이 대표적 시스템입니다.</p>
<p><img src="/images/02/codeReview.png" alt=""></p>
<h2 id="로컬-개발-환경"><a href="#로컬-개발-환경" class="headerlink" title="로컬 개발 환경"></a>로컬 개발 환경</h2><p>개발자들은 자신의 로컬 개발 환경을 갖춰야지 됩니다.</p>
<p>그리고, 개발환경의 구축은 다음과 같은 문제가 발생하게 됩니다. 다양한 인프라를 동시에 사용해야지 되는 프로젝트를 행하게 될때입니다.</p>
<p><strong>STEP01. 이제 시작입니다</strong><br><img src="/images/02/step01.jpg" alt=""><br><strong>STEP02. 약간 커졌습니다. 이쯤이야</strong><br><img src="/images/02/step02.jpg" alt=""><br><strong>STEP03. 아라라. 힘들어집니다</strong><br><img src="/images/02/step03.jpg" alt=""><br><strong>STEP04. 이건 좀… 무리가…</strong><br><img src="/images/02/step04.jpg" alt=""></p>
<p>그렇다면 개발서버에 모든 것을 설치해두고 사용하면 어떨까요.<br>개발서버에 모든 것을 설치하고, 개발자들이 각각 붙어서 작업하는 경우 많은 것들이 해결되게 됩니다. 그런데, 이 역시 문제를 가지고 있습니다.</p>
<ul>
<li>버젼이 변경되는 경우에 서버의 DB Schema의 변경이 이루어지게 된다.</li>
<li>네트워크가 끊기는 경우, 개발 역시 STOP.(원격지에서의 개발이 힘듬)</li>
<li>하나의 개발자의 행동이 다른 개발자들에게 동시에 영향을 줄 수 있음(DB 값의 변경, Memory Server의 restart)</li>
</ul>
<p>이러한 문제가 발생되기 때문에 개발서버를 사용하는 방법은 이제 구시대적 방법이라고 할 수 있습니다. 실제로 조금 개발에 대해서 잘 나간다는 회사들은 대부분 개발서버를 통해서 개발하는 방법을 버리고 있는 것이 사실입니다. 그럼 어떤 방법을 사용할까요.</p>
<p>첫번째는 가상머신입니다.<br>가상머신을 배포해서 가상머신과 로컬머신간의 네트워크 연결을 통해서 사용하는 방법이 있습니다.</p>
<p>이는 매우 좋은 해결책이 될 수 있습니다. 버젼별 가상머신을 관리하면, 유지보수에도 많은 도움이 될 수 있으며 가상머신의 snapshot 기능을 이용하면 DB의 특정 상태로도 restore가 가능하게 되는 많은 장점들을 가지고 있습니다.</p>
<p>그런데, 이 방법의 최대 단점은 용량입니다. 윈도우 머신의 경우, 조금 설치해서 서버를 올리면 60기가는 우스운 용량이 나오게 됩니다. 그리고 memory를 많이 사용하기 때문에 performance 역시 떨어지게 되는 것이 사실입니다.</p>
<p>두번째, 아니 이제 정답을 찾아가게 되면 docker를 이용하는 방법입니다.<br>Docker image에 위 환경을 만들어두고, 그 환경을 이용해서 다들 같이 개발을 하는 것이 일반적입니다. Docker image에 변경이 생길 사항이 생기거나 Docker에 들어있는 DB내용에 변경이 생기게 되면, 그 변경을 image에 반영할지를 개발자들끼리 결정을 하고, 그 변경이 반영된 image를 다시 배포하는 식으로 서로간의 개발단의 구성을 완벽하게 맞추어 개발을 진행합니다. Docker에 대해서는 개별 공부가 좀 더 필요할 것 같습니다.</p>
<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>개발환경은 <em>팀단위 개발환경</em>, <em>개인 개발환경</em>으로 나눌수 있습니다.<br><em>팀단위의 개발환경</em>은 개발프로세스에 따라 시스템적으로 지원이 되는 것이 일반적입니다. 이는 사내의 문화로 사용이 발전이 가능한 것으로 서로간에 논의해가야지 될 문제입니다.<br><em>개인 개발환경</em> 역시 팀에서 어떤 개발 프로세스로 진행할지에 따라 선택되는 방법의 차이가 있습니다. 개인적으로는 Docker 또는 가상서버를 통한 개발환경이 개발자들에게 도움이 될 것이라고 생각하는 편입니다. 이 부분에 대해서는 많은 논의가 필요할 것 같습니다.</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/study/">study</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2018/02/01/01-intro/"><span>01.intro</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/02/01/01-intro/" rel="bookmark">
        <time class="entry-date published" datetime="2018-02-01T03:40:57.000Z">
          2018-02-01
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h1 id="기술의-발전-amp-Application의-구조-변화"><a href="#기술의-발전-amp-Application의-구조-변화" class="headerlink" title="기술의 발전 &amp; Application의 구조 변화"></a>기술의 발전 &amp; Application의 구조 변화</h1><p>IT 기술은 다양한 분야를 가지고 있습니다. 기본적으로 정보에 대한 CRUD(create/read/update/delete) 로 구성되는 것이 일반적입니다.<br>단순 DB Row정보에 대한 CRUD로 이해하지 마시고, 정보의 <strong>생성/변경/삭제/읽기</strong>로 생각하시는 것이 좋습니다.</p>
<h2 id="초기-Stand-alone"><a href="#초기-Stand-alone" class="headerlink" title="초기 Stand alone"></a>초기 Stand alone</h2><p>웹 기술이 아닙니다. VB나 사내의 CS Application 형태로 구성되어 있습니다.<br>예전 윈도우즈에서 보여지고 있는 ODBC 연결이 그 흔적중 하나입니다.</p>
<p><img src="/images/01/odbcmodel.gif" alt=""></p>
<h2 id="2-Tier-초기-WWW-2006년"><a href="#2-Tier-초기-WWW-2006년" class="headerlink" title="2 Tier - 초기 WWW (~ 2006년)"></a>2 Tier - 초기 WWW (~ 2006년)</h2><p>Web 기술이 폭발적으로 발전하던 시기입니다. RDBMS의 발전으로 인하여 DB에 따른 Dynamic Web이 발전되게 됩니다. 이 Dynamic Web 기술에 대한 다양한 변형 기술들을 가지고 오게 됩니다.</p>
<p><img src="/images/01/image7.png" alt=""></p>
<h3 id="asp의-폭발적인-발전"><a href="#asp의-폭발적인-발전" class="headerlink" title="asp의 폭발적인 발전"></a>asp의 폭발적인 발전</h3><p>기존 개발자들의 70%정도를 차지하고 있던 visual basic 개발자들을 모두 web 개발자로 만들어주는 asp와 iis가 처음 선을 보이게 됩니다. 기존 visual basic 개발자들은 모두 db와 db를 표현하는 방식에 대해서 경험이 풍부한 사람들이였습니다. 그 개발자들을 모두 web 개발자로 만드는 엄청난 일을 MS가 성공하게 됩니다. 지금보면 참 문제가 많은 개발방법으로 개발하게 되지만, 그 당시에는 최고의 기술이였으며 누구나 쉽게 웹 프로그래밍에 접근할 수 있다는 점이 가장 큰 장점이였습니다.</p>
<h3 id="php의-발전-및-apache-httpd의-확장"><a href="#php의-발전-및-apache-httpd의-확장" class="headerlink" title="php의 발전 및 apache httpd의 확장"></a>php의 발전 및 apache httpd의 확장</h3><p>기존 standalone 서버에서 주로 사용되던 apache httpd를 이용한 dynamic web programming이 대두되게 됩니다. php는 asp의 장점을 흡수하고, 보다 쉬운 표현 방법을 제시합니다. 그리고 LAMP 라는 환경을 제시하기 때문에, 기업은 새로운 x86 windows server를 구매하는 것이 아닌 공짜로 web을 서비스할 수 있다는 점에서 기존 asp 시장을 잠식하기 시작합니다. 또한 linux 서버환경의 폭발적인 증가로 인하여 서버 환경이 기존 UNIX에서 linux 계열로 발전하게 된 계기가 됩니다.</p>
<h3 id="servlet과-asp-net의-발전"><a href="#servlet과-asp-net의-발전" class="headerlink" title="servlet과 asp .net의 발전"></a>servlet과 asp .net의 발전</h3><p>asp와 php로 인하여 dynamic web application이 엄청난 발전을 하게 됩니다. 하지만 asp와 php의 경우 언어의 특성상 큰 약점을 가지고 있습니다. page단위로 동작하게 되기 때문에, 현대적 프로그래밍 기법인 OOP를 사용할 수 없습니다. (방법은 있으나, 매우 괴악한 방법입니다.;) 점점 application이 거대화되어가면서 코드의 재 사용성 및 유지보수의 약점을 극복하기 위해서 asp와 php에 가려서 잠시 존재감을 잊어가고 있던 java와 .net이 다시 등장하게 됩니다.<br>두 언어는 RDBMS를 표현하는데 있어서 최선(?)의 방식을 가지고 있었으며, vm 기술의 발전으로 memory 및 performance에 강점을 가지고 있었기 때문에, 기존의 web 개발 시장을 빠르게 잠식해나가기 시작합니다.</p>
<h3 id="fat-client의-발전"><a href="#fat-client의-발전" class="headerlink" title="fat client의 발전"></a>fat client의 발전</h3><p>servlet과 asp .net의 발전은 RDBMS와 dynamic web application간의 여러 문제를 모두 해결해준것같지만 사용자들에게 다양한 경험을 보여주기 위한 View를 제공하는데에 있어서, 기존의 HTML만은 한계를 가지고 있었다. 동영상과 같은 멀티미디어를 포함하기에는 기존의 HTML이 지원하지 않는 부분이 너무나 많은 영역들이 있었기 때문입니다. 멀티미디어에 대한 지원을 강화하기 위해서 나온 첫 기술이 micromedia의 Flash입니다. Flash는 멀티미디어의 지원뿐 아니라, 웹을 보다 더 아름답게 만드는데 큰 공헌을 하게 됩니다. Flash의 대성공으로 MS는 asp로 마련했던 서버 시장에 심각한 타격을 입게 됩니다. 그래서 자사의 IIS + .NET Framework 기술로 동작하는 silverlight를 출시하기에 이릅니다. 이러한 멀티 미디어의 지원과 더불어, RDBMS에 특화된 fat client들이 나오게 되는데, PowerBuilder가 대표적입니다. 우리들에게는 <code>X-Client</code>, <code>X-Window</code>와 같은 이름들로 알려진것들이 많습니다.</p>
<p>fat client의 발전은 기존 servlet과 asp .net 기술과 충돌을 일으키게 됩니다. 단순히 servlet과 asp .net을 fat client의 container로 이용하게 되고 모든 로직을 fat client에서 처리하게 되는 개발 방법이 한 때 유행하게 됩니다.</p>
<h2 id="3-tier-N-tier-Cloud-시기-2006년"><a href="#3-tier-N-tier-Cloud-시기-2006년" class="headerlink" title="3 tier, N tier, Cloud 시기 (2006년 ~ )"></a>3 tier, N tier, Cloud 시기 (2006년 ~ )</h2><p>2 tier 가 발전한 형태입니다. 다양한 요구사항으로 인하여 기존 2 tier system의 확장을 통한 여러 시스템간의 결합으로 최종적으로는 enterprise system으로의 진화, 발전되었습니다. 기존 2 tier system에서는 해결할 수 없는 기술적 이슈들이 발생하게 됩니다. 다양한 시스템들이 나오게 되고 그 시스템들간의 상호 통신에 의하여 기존 2 tier 에서 n tier로 계속되는 발전이 이루어지게 됩니다.</p>
<p><img src="/images/01/3tier.svg" alt=""></p>
<h3 id="script-language의-발전"><a href="#script-language의-발전" class="headerlink" title="script language의 발전"></a>script language의 발전</h3><p>기존 .net과 java와는 다른 언어들이 발전하게 됩니다. 기존의 asp와 php가 OOP적 성격을 갖지 못한 단점을 해결하고 OOP적 장점과 개발의 편의성을 극대화한 script language가 발전하게 됩니다. python, ruby가 대두되기 시작하지요. 이 언어들은 기존의 객체 지향적인 특징과 asp, php와 같은 script 적 성격을 모두 갖게 됩니다. 개발의 속도, 변화 가능성에 대한 열린 대응을 토대로 이와 같은 script language가 계속된 발전을 하게 됩니다. 해외의 많은 시스템들이 하부 tier의 경우에는 ruby, python으로 개발된 것을 지금도 자주 볼 수 있습니다.</p>
<p>최근에는 hot하다고 할 수 있는 node.js가 script 언어중 가장 인기가 좋습니다.</p>
<h3 id="web-service의-개발"><a href="#web-service의-개발" class="headerlink" title="web service의 개발"></a>web service의 개발</h3><p>n tier system의 발전은 web service가 없었다면 불가능하다고 할 정도로 web service는 n tier system에 깊이 관여되어 있습니다. web service는 기존의 tier를 종적으로나 횡적으로 모두 확장을 시키는 가장 결정적인 역활을 하게 되는 계기가 되었습니다. “Service로서의 Web”에 대한 개념은 수많은 파생적 개념을 만들어 내고, 기술적 발전을 가지고 왔습니다. 기존에는 SOAP을 기반으로 한 web service가 주로 사용되었으나, 지금은 client(javascript) 등에서의 호출 문제로 인하여 xmlrpc의 경량화된 버젼인 REST를 주로 사용하고 있습니다. 이 REST에 대해서는 다시 한번 설명할 기회를 갖도록 하겠습니다.</p>
<h3 id="MVC의-발전"><a href="#MVC의-발전" class="headerlink" title="MVC의 발전"></a>MVC의 발전</h3><p>기존의 웹의 개발은 단순히 DB의 결과값을 웹에 표현하는 방식이였습니다. 대부분의 Business Logic은 DB에서 가지고 있고, 그 Business Logic을 web에 표현하는 방식이 대부분이였지요. 이렇게 된 가장 큰 이유중 하나는 웹으로 개발을 한 내용은 웹에 너무나 밀착되어있는 프로그램이라서, Business Logic만의 테스트가 거의 불가능하다는 것에서 시작되었습니다. 그렇지만, n tier system으로 발전해나가면서 tier만의 중복된 Business Logic을 정리 및 관리하는데 있어서 기존 프로그래밍 언어로 하고자 하는 욕구가 계속해서 발전되어 갑니다. DB Query 중심의 개발은 필연적인 중복코드와 로직의 누수가 발생하기 마련이니까요.</p>
<p>이때, ruby를 기반으로 한 ruby on rails가 발표됩니다. rails framework라고도 불리우는 이 framework는 기존의 web 개발 방법을 완전히 바꿔놓게 됩니다. 사용자에게 보여지는 영역인 View, Http response/request를 처리하는 Controller 마지막으로 Domain의 Business Logic을 처리하는 Model로 완벽한 영역을 분리할 수 있음을 ruby on rails는 보여주게 됩니다. 이러한 장점은 각 영역을 개발자들이 테스트를 해볼 수 있고, 영역에 대한 전문화를 분리시킬 수 있기 때문에 단숨에 웹 개발의 주도적 방법으로 대두되었습니다. java에서는 struct2가, .net에서는 asp .net mvc가 기존 ruby on rails의 사상을 반영한 MVC web framework입니다.</p>
<p>개발자는 지금 MVC를 중요하게 봐야지 됩니다. MVC 개발 방법은 웹뿐 아니라, 모든 application에 적용되어 있는 상황이고 각 영역에 대한 테스트를 통해서 자신의 코드의 완벽성을 스스로 검증할 수 있는 기회를 가지게 되었습니다. 에러에 대한 명확한 정의가 가능하게 되었으며, 에러가 발생했을때의 장애 처리와 같은 새로운 프로세스 정립 역시 MVC의 확립으로 가능하게 되었습니다. 이 부분은 지금까지는 개발자가 아닌, 기획이나 의사결정자들의 손에 있던 부분이였지만, 지금은 개발자들이 제시하는 방법을 선택하는 방향으로 전환이 된 상태입니다.</p>
<h3 id="mobile-기기의-발전-및-확산"><a href="#mobile-기기의-발전-및-확산" class="headerlink" title="mobile 기기의 발전 및 확산"></a>mobile 기기의 발전 및 확산</h3><p>기존 n tier system의 발전은 획적 확장에 해당된다면 mobile 기기의 발전 및 확산은 종적 확장에 해당됩니다.기존까지 있던 web application의 대상은 모두 PC의 browser를 대상으로 하고 있었습니다. PC를 기반으로 하고 있기 때문에 PC의 특정 browser만을 target으로 하고 개발이 가능해졌지요. 그렇지만, iPhone을 시작으로 한 mobile 기기의 발전은 이러한 생각을 모두 바꾸어놓게됩니다. 누구나 가지고 다니는 mobile 기기는 언제 어디에서나 접근이 가능한 특징을 가지고 있습니다. 이는 기존보다 많은 접속을 만들어 내고, 모든 device에서 동일하게 보여야지 된다는 문제를 가지고 오게 됩니다. 그리고, mobile device의 빈약한 시스템 자원과 기존 windows system과 다른 OS 환경으로 인하여 HTML의 표준화에 대한 요구 사항이 높아지게 됩니다.</p>
<h3 id="fat-client의-쇠퇴와-HTML5의-대두"><a href="#fat-client의-쇠퇴와-HTML5의-대두" class="headerlink" title="fat client의 쇠퇴와 HTML5의 대두"></a>fat client의 쇠퇴와 HTML5의 대두</h3><p>기존 flash와 silverlight와 같은 fat client가 mobile device에서 정상적으로 동작하지 않는 문제가 발생하게 됩니다. 이는 기존 PC에서도 windows-IE 환경 이외에서도 계속 지적되던 문제였지만, 본격적인 문제로서 국내에서는 대두되기 시작한 것은 바로 mobile 기기의 확산때문입니다. 기존 HTML에서 지원되지 않던 multimedia에 대한 지원을 비롯하여 animation과 websocket등의 표준화로 인하여 기존 flash와 silverlight가 설 자리가 없어지기 시작합니다. 지금 fat client는 flash만을 제외하고 거의 사장되어가는 분위기입니다. Flash의 경우에도 HTML5의 확산 전까지 잠시의 대체제로서의 의미 이외에는 퇴색해가는 것이 현실입니다. 기존 Flex 개발자들이 설 자리가 많이 없어지고 있지요.</p>
<h3 id="Big-data와-Cloud-의-대두"><a href="#Big-data와-Cloud-의-대두" class="headerlink" title="Big data와 Cloud 의 대두"></a>Big data와 Cloud 의 대두</h3><p>끊임없이 이야기가 나오고 있는 Big data와 Cloud는 mobile 기기의 발전 및 확산과 기존 web system의 오랜 발전으로 인하여 나온 기술이라고 할 수 있습니다. 기존의 RDBMS에서는 처리를 할 수 없을 정도의 데이터가 이제는 수집이 된 상태이고, 이 데이터들을 어떻게 분석을 해야지 될지. 이 데이터들을 어떻게 활용을 해야지 될지. 그리고 많은 mobile 기기에서 동시 다발적으로 들어오는 데이터를 어떻게 해야지 될지에 대한 물음에서 Big Data와 Cloud를 활용하는 방법을 찾아보는것이 방법일것 같습니다. 이러한 Big Data를 저장하기 위한 방법으로 cassandra, mongoDB, 등이 있으며 Big Data를 처리하기 위한 방법으로 Hadoop이 대두되게 됩니다. 또한 Cloud 시장은 아직 춘추전국의 시대와 같이 복잡한 상황이며, 시장 1위인 amazon의 AWS, MS의 Azure, Google의 Google Cloud Platform등이 경쟁을 하고 있습니다.</p>
<h2 id="개발자가-익혀야지-될-기술"><a href="#개발자가-익혀야지-될-기술" class="headerlink" title="개발자가 익혀야지 될 기술"></a>개발자가 익혀야지 될 기술</h2><h3 id="language-Java-Javascript"><a href="#language-Java-Javascript" class="headerlink" title="language - Java, Javascript"></a>language - Java, Javascript</h3><p>웹쪽 개발에 있어서 backend는 java, frontend는 javascript로 구성되는 것은 아주 일반적입니다. 근간에는 backend쪽도 node.js를 이용해서 frontend와 backend의 언어쪽 기술을 동일하게 들고가는 경우도 많습니다. 요즘은 Javascript의 시대라는 말이 나올정도로 javascript의 인기가 좋은 편입니다. 개발을 이제 시작하는 분들이 있다면 javascript도 꽤나 추천하고 싶은 언어입니다. 웹을 하기 위해서는 어차피 javascript를 해야지만 하니까요.</p>
<h3 id="Backend-Framework-Spring-Java-Express-node-js-Ko-node-js-python-django"><a href="#Backend-Framework-Spring-Java-Express-node-js-Ko-node-js-python-django" class="headerlink" title="Backend Framework - Spring(Java), Express(node.js), Ko(node.js), python(django)"></a>Backend Framework - Spring(Java), Express(node.js), Ko(node.js), python(django)</h3><p>언어가 정해지면, 그 언어를 이용해서 처음부터 열심히 만드는 것이 아닙니다. 많은 천재들이 만들어둔 Framework를 이용하는 것이 일반적입니다. 웹 개발에 있어서 Java측에서는 Spring Framework, node.js에서는 Express와 Ko가 주로 사용됩니다. Framework의 사용법을 익힌다는 것은 Framework의 사상을 이해하는 것이 필요합니다.</p>
<h3 id="Frontend-Framework-ReactJs-AngularJs-Angular2-Vue-js"><a href="#Frontend-Framework-ReactJs-AngularJs-Angular2-Vue-js" class="headerlink" title="Frontend Framework - ReactJs, AngularJs, Angular2, Vue.js"></a>Frontend Framework - ReactJs, AngularJs, Angular2, Vue.js</h3><p>Frontend분야의 발전은 놀라울 정도입니다. 지금 인기가 좋은 Frontend Framework의 경우에는 다음 것들 ReactJs, AngularJs, Angular2, Vue.js가 있습니다. 이 중 하나이상은 익혀두는 것이 좋습니다. 개인적으로는 Vue.js/React.js를 추천합니다.</p>
<h3 id="Data-Storage-Database-Big-Data-No-SQL-Memory-Db"><a href="#Data-Storage-Database-Big-Data-No-SQL-Memory-Db" class="headerlink" title="Data Storage - Database, Big-Data, No-SQL, Memory-Db"></a>Data Storage - Database, Big-Data, No-SQL, Memory-Db</h3><p>Database는 고전적인 이야기이긴 하지만, 여전히 중요한 분야입니다. 기존의 RDBMS뿐 아니라 다른 DB역시 필요합니다. memory db의 일종인 Redis는 이제 서비스를 운영하는 곳이라면 사용하지 않는 곳이 없을정도로 대중적인 인프라중 하나입니다. 또한 NO-SQL 진영에서의 MongoDb나 Big Data 부분에서의 Hadoop 역시 중요합니다. 어떤 분야에 대해서 공부를 할 것인지에 대해서는 많은 세미나를 가보는 것도 좋고, 다른 분야에 대한 관심을 계속해서 갖는 것이 필요합니다.</p>
<h3 id="HTTP-HTTP2"><a href="#HTTP-HTTP2" class="headerlink" title="HTTP, HTTP2"></a>HTTP, HTTP2</h3><p>HTTP는 계속해서 발전되어가면서 지금은 HTTP2의 시대가 오고 있습니다. 웹의 기초가 되는 HTTP가 어떻게 동작하고 있는지에 대한 공부는 계속해서 필요합니다. 그리고 HTTP2가 이제 상용화가 되고 있는 시점이기 때문에, 이에 대한 개발 방법의 변화등도 따라가야지 됩니다. 언제까지 옛날 기술에 계속해서 매몰되어갈 필요는 없습니다.</p>
<h3 id="Modeling"><a href="#Modeling" class="headerlink" title="Modeling"></a>Modeling</h3><p>Modeling은 소위 말하는 ‘업무분석’ 과정입니다. 업무를 분석하고 분석한 업무를 programming language로 구현 가능한 형태로 추상화를 시키는 과정을 의미합니다. 개발자의 생각의 방향은 학교에서 자주 들은 Divide &amp; conquer 입니다. 작게 나누고, 하나하나 해결해나가고. 그 해결한 조그마한 것들을 다시 붙이는 작업들이 필요합니다.</p>
<p>Machine Learning에 있어서도 역시 Modeling은 가장 중요한 일중 하나가 되어 있습니다. <strong>실 상황을 우리가 생각하는 공학적인 분야로 이동시키는 것</strong> 이것이 Modeling의 본질이 됩니다.</p>
<h3 id="개발-방법론"><a href="#개발-방법론" class="headerlink" title="개발 방법론"></a>개발 방법론</h3><p>개발 방법론은 Agile을 기반으로 한 scrum, kanban 등이 인기를 끌고 있습니다. 개발만을 중심으로 생각한다면 TDD(Test Driven Development)가 있습니다. TOP-DOWN 방식으로 진행이 된다면 그에 따르면 좋겠지만, 그것이 안된다면 자신이 자기만의 개발 패턴을 만들기 위해서라도 간단한 이론등을 아는 것이 좋습니다.</p>
<h3 id="Design-pattern"><a href="#Design-pattern" class="headerlink" title="Design pattern"></a>Design pattern</h3><p>개발 방법론과 매우 유사한 분야입니다. 개발을 할때, 코드를 최적화 하는 패턴들이 존재합니다. 패턴을 익히는 것보다는 패턴을 이용해서 개발자들끼리의 의사소통이 가능해져야지 됩니다. 개발자들끼리 사용하는 약어가 되는 경우가 꽤나 많습니다. 그리고 책을 통해서 학습을 할때도 유용합니다.</p>
<h3 id="단위-테스트-Unit-Test"><a href="#단위-테스트-Unit-Test" class="headerlink" title="단위 테스트 (Unit Test)"></a>단위 테스트 (Unit Test)</h3><p>개발자는 자신이 만든 모든 s/w를 테스트할 수 있어야지 되고, 그 테스트한 결과로서 자신의 s/w의 품질을 증명할 수 있어야지 됩니다. “내가 하면 되었는데.”, “어제는 되었는데.” 식의 이야기는 곤란합니다. in/out이 결정나면 그 in/out에 대한 명확한 테스트를 하고 그 테스트 결과를 보여줄 수 있어야지 됩니다. 또한 s/w의 규모가 크면 클수록 그 코드를 검증할 수 있어야지 됩니다. 이제는 테스트를 돌리기 위해서 개발을 한다. 라는 말이 나올 정도로 테스트는 일반화된 기술입니다. 자동화된 테스트를 구성하는 능력은 반드시 필요합니다.</p>
<h3 id="Infrastructure-Cloud-Docker-env"><a href="#Infrastructure-Cloud-Docker-env" class="headerlink" title="Infrastructure (Cloud, Docker env)"></a>Infrastructure (Cloud, Docker env)</h3><p>이제는 환경을 제공하는 Cloud를 기반으로 하여 개발 및 서비스가 진행되어가는 시대입니다. Cloud, Docker를 기반으로 하는 환경에서는 역시 이 환경에 대한 이해가 반드시 필요합니다.</p>
<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>웹어플리케이션은 지난 20여년동안 눈부시게 발전한 분야입니다. 여러 패러다임들의 변화가 끊임없이 있었습니다. 지금 한국에서 가장 주가 되어 있는 <code>Java</code>를 기준으로 Application 개발 방법에 대해서 한번 같이 알아보도록 하겠습니다.</p>
<p>마지막으로… 제가 Java를 해야지 된다고 이야기를 했지만, 현 2018년의 server-side programing language의 현 사용률은 다음과 같습니다. 국내는 자료 못찾았습니다.</p>
<p><img src="/images/01/flow.png" alt=""></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/study/">study</a>
    </span>
    

    </div>

    
  </div>
</article>




<nav class="pagination">
  
  <a href="/" class="pagination-prev">Prev</a>
  
  
</nav>
    </main>

    <footer class="site-footer">
  <p class="site-info">
    Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
    Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
    </br>
    
    &copy; 2018 ykyoon
    
  </p>
</footer>
    
  </div>
</div>
</body>
</html>