<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>16. Web Development | Programming is Fun | Still waters run deep. When the well&#39;s dry, we know the worth of water.</title>

  
  <meta name="author" content="ykyoon">
  

  
  <meta name="description" content="16. Web 개발web application소프트웨어 공학에서 웹 애플리케이션(web application) 또는 웹 앱은 웹 브라우저에서 이용할 수 있는 응용 소프트웨어를 이야기합니다. 이는 우리가 개발하는 거의 대부분의 web site를 이야기합니다.
이런 web">
  

  
  
  <meta name="keywords" content="web, rest, development">
  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  <meta property="og:title" content="16. Web Development"/>

  <meta property="og:site_name" content="Programming is Fun"/>

  
  <meta property="og:image" content="/favicon.ico"/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="Programming is Fun" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
</head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">Programming is Fun</a>
    </h1>
    <p class="site-description">Still waters run deep. When the well&#39;s dry, we know the worth of water.</p>
  </div>
  <nav class="site-navigation">
    <ul>
      
        <li><a href="/">Home</a></li>
      
        <li><a href="/archives">Archives</a></li>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    <article>

  
    
    <h3 class="article-title"><span>16. Web Development</span></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/05/02/web-development/" rel="bookmark">
        <time class="entry-date published" datetime="2018-05-02T13:31:46.000Z">
          2018-05-02
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h1 id="16-Web-개발"><a href="#16-Web-개발" class="headerlink" title="16. Web 개발"></a>16. Web 개발</h1><h2 id="web-application"><a href="#web-application" class="headerlink" title="web application"></a>web application</h2><p>소프트웨어 공학에서 웹 애플리케이션(web application) 또는 웹 앱은 웹 브라우저에서 이용할 수 있는 응용 소프트웨어를 이야기합니다. 이는 우리가 개발하는 거의 대부분의 web site를 이야기합니다.</p>
<p>이런 web site는 다음과 같은 요소의 결합으로 만들어집니다.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HTML(구조) + CSS(Style) + JS(Action, Event Handling)</span><br></pre></td></tr></table></figure>
<p>여기에서 개발자들이 HTML, CSS 영역 모두를 개발하는 경우가 일반적입니다. HTML과 CSS는 디자인에 매우 밀접하게 영향을 받습니다.</p>
<h3 id="Holy-Grail-Layout"><a href="#Holy-Grail-Layout" class="headerlink" title="Holy Grail Layout"></a>Holy Grail Layout</h3><p>매우 일반적인 web application의 layout입니다.</p>
<p><img src="http://alistapart.com/d/holygrail/diagram_01.gif" alt=""></p>
<p>web application을 혼자서 구성을 해야지 된다면, <code>Holy Grail Layout</code>에 대한 css를 구성하고, 그 안에 디자인과 Content를 채워나가면 일반적인 web application을 구성할 수 있습니다. 이때 주의할 점은 browser의 버젼입니다. <code>Holy Grail Layout</code>을 구성하는 HTML/CSS는 browser에 따라 지원가능한 정의가 매우 다릅니다. 먼저, 어떤 browser를 지원할지를 결정을 하고, 그 후 <code>Holy Grail Layout</code>을 구성하는 것이 좋습니다.</p>
<p><code>Holy Grail Layout</code>을 구성하는 방법에 대해서는 다음 article을 참조하는 것이 좋습니다.</p>
<p><a href="https://hyunseob.github.io/solved-by-flexbox-kr/demos/holy-grail/" target="_blank" rel="noopener">https://hyunseob.github.io/solved-by-flexbox-kr/demos/holy-grail/</a><br><a href="https://opentutorials.org/course/2418/13526" target="_blank" rel="noopener">https://opentutorials.org/course/2418/13526</a></p>
<h3 id="javascript-Library"><a href="#javascript-Library" class="headerlink" title="javascript Library"></a>javascript Library</h3><p>우리는 지금까지 java application을 구성하면서 dependency를 관리해왔습니다. gradle에서는 <code>build.gradle</code>을 통해, maven에서는 <code>pom.xml</code>을 통해서 dependency를 구성하고, 그에 대한 version을 계속해서 관리하고 있는 것을 알수 있습니다. 우리는 web application을 만들면서 많은 library들을 사용해야지 됩니다. 가장 많이 쓰이는 <code>jquery</code>나 <code>bootstrap</code>과 같은 library들도 있고, 특별한 계산을 위한 library들이나 javascript의 collection기능의 강화를 위한 <code>lodash</code>등의 수많은 library들을 사용할 수 있습니다.</p>
<p>이를 구조적으로 관리할 수 있는 tool로 <code>bower</code>와 <code>npm</code>이 있습니다. <code>bower</code>는 더 이상관리되고 있지 않기 때문에 논의하지 않기로 하고 여기서는 <code>npm</code>만 이야기하도록 하겠습니다.</p>
<h4 id="npm-소개"><a href="#npm-소개" class="headerlink" title="npm 소개"></a>npm 소개</h4><p><code>npm</code>은 <code>node.js</code>에서 사용되는 dependency 관리툴입니다. <code>node.js</code>를 설치하면 같이 설치됩니다. <code>npm</code>은 3.0을 기준으로 그 전에는 <code>backend</code>부분의 dependency만을 관리하였으나, 3.0 이후부터는 모든 javascript library들에 대한 dependency를 관리합니다.</p>
<h4 id="npm을-이용한-website-개발"><a href="#npm을-이용한-website-개발" class="headerlink" title="npm을 이용한 website 개발"></a>npm을 이용한 website 개발</h4><p>web site를 개발할 folder에서 다음 명령어를 실행합니다. <code>java web application</code>에서는 <code>src/main/webapp</code> 폴더가 됩니다.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm init</span><br></pre></td></tr></table></figure>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"temp"</span>,</span><br><span class="line">  <span class="attr">"version"</span>: <span class="string">"1.0.0"</span>,</span><br><span class="line">  <span class="attr">"description"</span>: <span class="string">""</span>,</span><br><span class="line">  <span class="attr">"main"</span>: <span class="string">"index.js"</span>,</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"test"</span>: <span class="string">"echo \"Error: no test specified\" &amp;&amp; exit 1"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"author"</span>: <span class="string">""</span>,</span><br><span class="line">  <span class="attr">"license"</span>: <span class="string">"ISC"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>이제 구성된 folder에서 bootstrap을 추가해보도록 하겠습니다.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install bootstrap --save</span><br></pre></td></tr></table></figure>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">secucen  ~/temp  npm install bootstrap --save</span><br><span class="line">npm WARN bootstrap@<span class="number">4</span>.<span class="number">0</span>.<span class="number">0</span> requires a peer of jquery@<span class="number">1</span>.<span class="number">9</span>.<span class="number">1</span> - <span class="number">3</span> but none is installed. You must install peer dependencies yourself.</span><br><span class="line">npm WARN bootstrap@<span class="number">4</span>.<span class="number">0</span>.<span class="number">0</span> requires a peer of popper.js@^<span class="number">1</span>.<span class="number">12</span>.<span class="number">9</span> but none is installed. You must install peer dependencies yourself.</span><br><span class="line">npm WARN temp@<span class="number">1</span>.<span class="number">0</span>.<span class="number">0</span> No description</span><br><span class="line">npm WARN temp@<span class="number">1</span>.<span class="number">0</span>.<span class="number">0</span> No repository field.</span><br><span class="line"></span><br><span class="line">+ bootstrap@<span class="number">4</span>.<span class="number">0</span>.<span class="number">0</span></span><br><span class="line">updated <span class="number">1</span> package <span class="keyword">in</span> <span class="number">0</span>.<span class="number">885</span>s</span><br></pre></td></tr></table></figure>
<p>이제 <code>package.json</code>파일을 확인해보면 <code>bootstrap</code>이 추가 된것을 확인할 수 있습니다.</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"temp"</span>,</span><br><span class="line">  <span class="attr">"version"</span>: <span class="string">"1.0.0"</span>,</span><br><span class="line">  <span class="attr">"description"</span>: <span class="string">""</span>,</span><br><span class="line">  <span class="attr">"main"</span>: <span class="string">"index.js"</span>,</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"test"</span>: <span class="string">"echo \"Error: no test specified\" &amp;&amp; exit 1"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"author"</span>: <span class="string">""</span>,</span><br><span class="line">  <span class="attr">"license"</span>: <span class="string">"ISC"</span>,</span><br><span class="line">  <span class="attr">"dependencies"</span>: &#123;</span><br><span class="line">    <span class="attr">"bootstrap"</span>: <span class="string">"^4.0.0"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>bootstrap</code>을 추가할 때 발생한 <code>WARN</code>을 확인해보도록 하겠습니다. <code>jquery</code>와 <code>popper</code>를 설치하라고 경고가 발생하고 있는 것을 알 수 있습니다. 차례대로 추가해주면 <code>bootstrap</code>을 사용할 수 있는 모든 준비는 마쳐집니다.</p>
<h4 id="npm-directory-구조"><a href="#npm-directory-구조" class="headerlink" title="npm directory 구조"></a>npm directory 구조</h4><p><code>npm</code>을 이용해서 dependency를 추가하는 경우, <code>node_modules</code> 라는 폴더가 만들어지고, 이 안에 library들이 다운받아집니다. 이 폴더를 기준으로 html에 <code>&lt;script include=&quot;/node_modules/...&quot;&gt;&lt;/script&gt;</code> 시켜주시면 됩니다.</p>
<h3 id="제안되는-web-application-structure"><a href="#제안되는-web-application-structure" class="headerlink" title="제안되는 web application structure"></a>제안되는 web application structure</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── assets</span><br><span class="line">│   └── images</span><br><span class="line">├── node_modules</span><br><span class="line">├── script</span><br><span class="line">├── style</span><br><span class="line">│   └── images</span><br><span class="line">├── view</span><br><span class="line">├── index.html</span><br><span class="line">├── package-lock.json</span><br><span class="line">└── package.json</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>path</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td>assets(static)</td>
<td>static file을 모으는 곳입니다. image, pdf, excel 등의 다양한 정적 resource를 저장합니다.</td>
</tr>
<tr>
<td>script</td>
<td>내부에서 작성된 javascript를 모으는 곳입니다.</td>
</tr>
<tr>
<td>style</td>
<td>css가 위치하는 곳입니다.</td>
</tr>
<tr>
<td>style/image</td>
<td>css에서 사용되는 image들을 위치하는 폴더입니다.</td>
</tr>
<tr>
<td>view</td>
<td>html 파일들을 위치하는 곳입니다.</td>
</tr>
</tbody>
</table>
<h2 id="Web의-두가지-구조-Server-side-rendering-SSR-vs-Client-side-rendering-CSR"><a href="#Web의-두가지-구조-Server-side-rendering-SSR-vs-Client-side-rendering-CSR" class="headerlink" title="Web의 두가지 구조 - Server side rendering(SSR) vs Client side rendering(CSR)"></a>Web의 두가지 구조 - Server side rendering(SSR) vs Client side rendering(CSR)</h2><p>지금까지 Spring View를 통해서 다양한 html을 표현하는 방법에 대해서 알아봤습니다. tomcat과 같은 was서버는 주어진 http request를 처리하고 그 결과 처리에 대한 내용을 특정 view로 보내게 됩니다. 이때 데이터가 완성된 형태로 보내지게 된다면 이를 <code>Server Side Rendering</code> 방식의 page라고 합니다.</p>
<p>전통적인 방식의 SSR의 동작 방식은 다음과 같습니다.</p>
<p><img src="/images/16/server_side_rendering_1.png" alt="&quot;image&quot;"></p>
<p>request마다 새로고침이 발생하면서 서버에 새로운 page(html)을 요청하는 방식입니다. 이 때, View가 어떻게 보여질지 서버에서 해석해서 보내주게 됩니다. 지금까지 알아봤던 Spring에서의 View는 모두 SSR입니다.</p>
<p>이러한 SSR은 서버측에서 html을 생성(render)하는 과정을 거치게 되기 때문에 서버측에 부하가 커질 수 있으며 mobile 환경에서 모든 page가 새로 고침과 같은 형태로 구성되는 것에 대한 네트워크/기기성능 상의 부하를 가지고 오게 되었습니다. 이를 해결하기 위해서 CSR 방식이 제안되게 되었습니다.</p>
<p><img src="/images/16/client_side_rendering_1.png" alt="&quot;image&quot;"></p>
<p>CSR은 보여지는 기본 뼈대가 되는 image, html, css와 같은 static resource를 이미 로드 한 후, 서버측으로 변경되는 데이터를 요청해서 그 데이터 이용하여 보여지는 방식입니다.</p>
<p>CSR과 SSR. 어느 한쪽이 압도적으로 우위에 있는 것은 아닙니다. 둘은 장/단을 가지고 있습니다.</p>
<h3 id="SSR-장점"><a href="#SSR-장점" class="headerlink" title="SSR 장점"></a>SSR 장점</h3><ul>
<li>모든 robot crawling에 노출되기 때문에 SEO(search engine optimization)에 유리하다.</li>
<li>Client의 Browser의 memory issue를 피할 수 있다.</li>
</ul>
<h3 id="SSR-단점"><a href="#SSR-단점" class="headerlink" title="SSR 단점"></a>SSR 단점</h3><ul>
<li>서버사이드에서 매번 처리가 되기 때문에 서버측의 CPU/Memory 부하가 크다.</li>
<li>서버측에서 Page가 모두 만든 후, 반환되므로 서버측의 응답이 늦어질 수 있다.</li>
</ul>
<h3 id="CSR-장점"><a href="#CSR-장점" class="headerlink" title="CSR 장점"></a>CSR 장점</h3><ul>
<li>View의 Rendering을 Client에서 구성하기 때문에 서버측의 CPU/Memory 부하를 줄일 수 있다.</li>
<li>정적인 파일들(html, js, css)와 동적인 데이터가 완벽하게 분리가 되기 때문에 CDN(content delivery network) 서비스에 매우 최적화 될 수 있다.</li>
</ul>
<h3 id="CSR-단점"><a href="#CSR-단점" class="headerlink" title="CSR 단점"></a>CSR 단점</h3><ul>
<li>google이외의 robot crawling에 노출되지 않는 경우가 발생한다.</li>
<li>Client Browser에서의 memory leak과 부하에 대한 고려가 될 수 있는 설계가 필요하다.</li>
</ul>
<h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><p>위에서 소개한 CSR은 이제 거의 대부분의 웹을 이루는 구조가 되었습니다. 이제 이 부분을 철저하게 분리하여 단순 파일들(html, js, css)를 지원하는 static server와 주어진 query에 따라 다른 데이터를 보내주는 <code>API</code>로 구분할 수 있습니다. <code>API</code>의 역사는 매우 오래되었습니다. 위에서 나온 <code>CSR</code>, <code>SSR</code>과 비슷한 역사를 가지고 있습니다.</p>
<p>먼저, <code>WebService</code>라는 기술부터 최신의 <code>REST</code>까지 한번 알아보도록 하겠습니다.</p>
<h2 id="WebService"><a href="#WebService" class="headerlink" title="WebService"></a>WebService</h2><p>네트워크 상에서 서로 다른 종류의 컴퓨터들 간에 상호작용을 하기 위한 소프트웨어 시스템입니다. 웹 서비스는 서비스 지향적 분산 컴퓨팅 기술의 일종입니다. 웹 서비스 프로토콜 스택은 SOAP, WSDL, UDDI 등으로 이루어지고 있으며, 모든 메시징에 XML이 사용되어 상호운용성이 높습니다.</p>
<p>다음과 같은 특징을 가지고 있습니다.</p>
<ul>
<li>느슨한 연결(loose coupling)</li>
<li>이진 부호화(바이너리 인코딩)가 아닌 XML 유니코드 부호화를 사용한다.</li>
<li>개체 지향(object-oriented)이 아닌 메시지 지향(message-oriented)이다.</li>
</ul>
<p>위에서 이야기한 SOAP, WSDL, UDDI의 경우에는 지금 거의 사용되고 있지않습니다. 지금은 REST을 이용한 WebService가 주류가 되어 사용되고 있습니다. REST에 대해서 좀 더 알아보도록 하겠습니다.</p>
<h2 id="REST-Representaational-State-Transfer-API"><a href="#REST-Representaational-State-Transfer-API" class="headerlink" title="REST (Representaational State Transfer API)"></a>REST (Representaational State Transfer API)</h2><h3 id="기원"><a href="#기원" class="headerlink" title="기원"></a>기원</h3><p>REST는 Representational State Transfer라는 용어의 약자로서 2000년도에 로이 필딩 (Roy Fielding)의 박사학위 논문에서 최초로 소개되었습니다. 로이 필딩은 HTTP의 주요 저자 중 한 사람으로 그 당시 웹(HTTP) 설계의 우수성에 비해 제대로 사용되어지지 못하는 모습에 안타까워하며 웹의 장점을 최대한 활용할 수 있는 아키텍처로써 REST를 발표했다고 합니다.</p>
<h3 id="구성"><a href="#구성" class="headerlink" title="구성"></a>구성</h3><p>REST API는 다음의 구성으로 이루어져있습니다. 자세한 내용은 밑에서 설명하도록 하겠습니다.</p>
<ul>
<li>자원(RESOURCE)에 대한 정의 - URI</li>
<li>행위(Verb) - HTTP METHOD</li>
<li>표현(Representations) 방식 - JSON</li>
</ul>
<h3 id="특징"><a href="#특징" class="headerlink" title="특징"></a>특징</h3><ul>
<li><p>Uniform (유니폼 인터페이스)</p>
<blockquote>
<p>Uniform Interface는 URI로 지정한 리소스에 대한 조작을 통일되고 한정적인 인터페이스로 수행하는 아키텍처 스타일을 말합니다.</p>
</blockquote>
</li>
<li><p>Stateless (무상태성)</p>
<blockquote>
<p>REST는 무상태성 성격을 갖습니다. 다시 말해 작업을 위한 상태정보를 따로 저장하고 관리하지 않습니다. 세션 정보나 쿠키정보를 별도로 저장하고 관리하지 않기 때문에 API 서버는 들어오는 요청만을 단순히 처리하면 됩니다. 때문에 서비스의 자유도가 높아지고 서버에서 불필요한 정보를 관리하지 않음으로써 구현이 단순해집니다.</p>
</blockquote>
</li>
<li><p>Cacheable (캐시 가능)</p>
<blockquote>
<p>REST의 가장 큰 특징 중 하나는 HTTP라는 기존 웹표준을 그대로 사용하기 때문에, 웹에서 사용하는 기존 인프라를 그대로 활용이 가능합니다. 따라서 HTTP가 가진 캐싱 기능이 적용 가능합니다. HTTP 프로토콜 표준에서 사용하는 Last-Modified태그나 E-Tag를 이용하면 캐싱 구현이 가능합니다.</p>
</blockquote>
</li>
<li><p>Self-descriptiveness (자체 표현 구조)</p>
<blockquote>
<p>REST의 또 다른 큰 특징 중 하나는 REST API 메시지만 보고도 이를 쉽게 이해 할 수 있는 자체 표현 구조로 되어 있다는 것입니다.</p>
</blockquote>
</li>
<li><p>Client - Server 구조</p>
<blockquote>
<p>REST 서버는 API 제공, 클라이언트는 사용자 인증이나 컨텍스트(세션, 로그인 정보)등을 직접 관리하는 구조로 각각의 역할이 확실히 구분되기 때문에 클라이언트와 서버에서 개발해야 할 내용이 명확해지고 서로간 의존성이 줄어들게 됩니다.</p>
</blockquote>
</li>
<li><p>계층형 구조</p>
<blockquote>
<p>REST 서버는 다중 계층으로 구성될 수 있으며 보안, 로드 밸런싱, 암호화 계층을 추가해 구조상의 유연성을 둘 수 있고 PROXY, 게이트웨이 같은 네트워크 기반의 중간매체를 사용할 수 있게 합니다.</p>
</blockquote>
</li>
</ul>
<h3 id="REST-API-Design-Guide"><a href="#REST-API-Design-Guide" class="headerlink" title="REST API Design Guide"></a>REST API Design Guide</h3><p>REST API 설계 시 가장 중요한 항목은 다음의 2가지로 요약할 수 있습니다.</p>
<p>첫 번째, URI는 정보의 자원을 표현해야 한다. 즉 URI는 정보에 대한 ID로서 사용될 수 있어야지 됩니다.<br>두 번째, 자원에 대한 행위는 HTTP Method(GET, POST, PUT, DELETE)로 표현한다.</p>
<p>다른 것은 다 잊어도 위 내용은 꼭 기억하시길 바랍니다.</p>
<h4 id="REST-API-중심-규칙"><a href="#REST-API-중심-규칙" class="headerlink" title="REST API 중심 규칙"></a>REST API 중심 규칙</h4><h5 id="URI는-정보의-자원을-표현해야-한다-리소스명은-동사보다는-명사를-사용"><a href="#URI는-정보의-자원을-표현해야-한다-리소스명은-동사보다는-명사를-사용" class="headerlink" title="URI는 정보의 자원을 표현해야 한다. (리소스명은 동사보다는 명사를 사용)"></a>URI는 정보의 자원을 표현해야 한다. (리소스명은 동사보다는 명사를 사용)</h5><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /members/delete/<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>위와 같은 방식은 REST를 제대로 적용하지 않은 URI입니다. URI는 자원을 표현하는데 중점을 두어야 합니다. delete와 같은 행위에 대한 표현이 들어가서는 안됩니다.<br>URI를 설계할 때에는 다음과 같은 규칙을 지키는 것이 좋습니다.</p>
<ul>
<li>슬래시 구분자(/)는 계층 관계를 나타내는 데 사용한다.</li>
<li>URI 마지막 문자로 슬래시(/)를 포함하지 않는다.</li>
<li>하이픈(-)은 URI 가독성을 높이는데 사용한다.</li>
<li>밑줄(_)은 URI에 사용하지 않는다.</li>
<li>URI 경로에는 소문자가 적합하다.</li>
<li>파일 확장자는 URI에 포함시키지 않는다. REST API에서는 메시지 바디 내용의 포맷을 나타내기 위한 파일 확장자를 URI 안에 포함시키지 않습니다. Accept header를 사용하도록 합시다.</li>
</ul>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET / members/soccer/<span class="number">345</span>/photo HTTP/<span class="number">1</span>.<span class="number">1</span> Host: restapi.example.com Accept: image/jpg</span><br></pre></td></tr></table></figure>
<h5 id="자원에-대한-행위는-HTTP-Method-GET-POST-PUT-DELETE-등-로-표현"><a href="#자원에-대한-행위는-HTTP-Method-GET-POST-PUT-DELETE-등-로-표현" class="headerlink" title="자원에 대한 행위는 HTTP Method(GET, POST, PUT, DELETE 등)로 표현"></a>자원에 대한 행위는 HTTP Method(GET, POST, PUT, DELETE 등)로 표현</h5><p>위의 잘못 된 URI를 HTTP Method를 통해 수정해 보면</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE /members/<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>으로 수정할 수 있겠습니다.<br>회원정보를 가져올 때는 GET, 회원 추가 시의 행위를 표현하고자 할 때는 POST METHOD를 사용하여 표현합니다.</p>
<p>회원정보를 가져오는 URI</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET /members/show/<span class="number">1</span>     (x)</span><br><span class="line">GET /members/<span class="number">1</span>          (o)</span><br></pre></td></tr></table></figure>
<p>회원을 추가할 때</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET /members/insert/<span class="number">2</span> (x)  - GET 메서드는 리소스 생성에 맞지 않습니다.</span><br><span class="line">POST /members/<span class="number">2</span>       (o)</span><br></pre></td></tr></table></figure>
<p>HTTP method에 따른 CRUD는 다음과 같습니다.</p>
<table>
<thead>
<tr>
<th>METHOD</th>
<th>CRUD</th>
<th>DESCRIPTION</th>
</tr>
</thead>
<tbody>
<tr>
<td>POST</td>
<td>C</td>
<td>POST를 통해 해당 URI를 요청하면 리소스를 생성합니다.</td>
</tr>
<tr>
<td>GET</td>
<td>R</td>
<td>GET을 통해 해당 리소스를 조회합니다.</td>
</tr>
<tr>
<td>PUT</td>
<td>U</td>
<td>해당 리소스를 수정합니다.</td>
</tr>
<tr>
<td>DELETE</td>
<td>D</td>
<td>DELETE를 통해 해당 리소스를 삭제합니다.</td>
</tr>
</tbody>
</table>
<h5 id="API의-결과에-대한-응답은-HTTP-응답상태-코드를-활용한다"><a href="#API의-결과에-대한-응답은-HTTP-응답상태-코드를-활용한다" class="headerlink" title="API의 결과에 대한 응답은 HTTP 응답상태 코드를 활용한다."></a>API의 결과에 대한 응답은 HTTP 응답상태 코드를 활용한다.</h5><p>잘 설계된 REST API는 URI만 잘 설계된 것이 아닌 그 리소스에 대한 응답을 잘 내어주는 것까지 포함되어야 합니다. 정확한 응답의 상태코드만으로도 많은 정보를 전달할 수가 있기 때문에 응답의 상태코드 값을 명확히 돌려주는 것은 생각보다 중요한 일이 될 수도 있습니다. 혹시 200이나 4XX관련 특정 코드 정도만 사용하고 있다면 처리 상태에 대한 좀 더 명확한 상태코드 값을 사용할 수 있기를 권장하는 바입니다.<br>상태코드에 대해서는 몇 가지만 정리하도록 하겠습니다.</p>
<table>
<thead>
<tr>
<th>상태코드</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>200</td>
<td>클라이언트의 요청을 정상적으로 수행함</td>
</tr>
<tr>
<td>201</td>
<td>클라이언트가 어떠한 리소스 생성을 요청, 해당 리소스가 성공적으로 생성됨(POST를 통한 리소스 생성 작업 시)</td>
</tr>
<tr>
<td>400</td>
<td>클라이언트의 요청이 부적절 할 경우 사용하는 응답 코드</td>
</tr>
<tr>
<td>401</td>
<td>클라이언트가 인증되지 않은 상태에서 보호된 리소스를 요청했을 때 사용하는 응답 코드 (로그인 하지 않은 유저가 로그인 했을 때, 요청 가능한 리소스를 요청했을 때)</td>
</tr>
<tr>
<td>403</td>
<td>유저 인증상태와 관계 없이 응답하고 싶지 않은 리소스를 클라이언트가 요청했을 때 사용하는 응답 코드 (403 보다는 400이나 404를 사용할 것을 권고. 403 자체가 리소스가 존재한다는 뜻이기 때문에 보안상 안전하지 않음)</td>
</tr>
<tr>
<td>405</td>
<td>클라이언트가 요청한 리소스에서는 사용 불가능한 Method를 이용했을 경우 사용하는 응답 코드</td>
</tr>
<tr>
<td>301</td>
<td>클라이언트가 요청한 리소스에 대한 URI가 변경 되었을 때 사용하는 응답 코드 (응답 시 Location header에 변경된 URI를 적어 줘야 합니다.)</td>
</tr>
<tr>
<td>500</td>
<td>서버에 문제가 있을 경우 사용하는 응답 코드</td>
</tr>
</tbody>
</table>
<h5 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h5><p>web의 개발은 대체적으로 사용되는 style이 정해져있습니다. <code>Holy Grail Layout</code>을 사용하는 것이 매우 일반적입니다.</p>
<p>web은 다음 3가지의 정적인 resource의 결합으로 구성됩니다.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HTML(구조) + CSS(Style) + JS(Action, Event Handling)</span><br></pre></td></tr></table></figure>
<p>정적인 resource를 제외한 dynamic data의 경우에는 server side render를 통해서 구성된 view를 통해서 구현되거나 외부의 web service를 통해서 rendering이 됩니다.</p>
<p>위 3가지 규칙을 잘 지킨 REST API를 구성하는 것이 중요합니다. REST API는 URI, METHOD를 통한 <code>self-description</code>이 가능하도록 하는 것이 핵심입니다.<br>잘 설계된 REST API는 딱히 문서가 필요없을 정도로 간결하게 구성이 가능합니다.</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/web-rest-development/">web, rest, development</a>
    </span>
    

    </div>

    
  </div>
</article>


    </main>

    <footer class="site-footer">
  <p class="site-info">
    Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
    Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
    </br>
    
    &copy; 2018 ykyoon
    
  </p>
</footer>
    
  </div>
</div>
</body>
</html>